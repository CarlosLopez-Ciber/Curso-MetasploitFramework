---
title: Extension del desarrollo de Metasploit y exploits
---
# Extension del desarrollo de Metasploit y exploits

## Conceptos Fundamentales en el Desarrollo de Exploits

### 1. Tipologías y Ciclo de Vida del Desarrollo de Exploits

- **Plataforma Objetivo:** Sistemas operativos específicos (ej. Windows, Linux, macOS), arquitecturas de hardware (ej. x86, x64, ARM) o entornos de _software_ (ej. aplicaciones web, bases de datos).
- **Vector de Ataque:** Remoto (sin acceso físico), local (requiere acceso previo), cliente-lado (interacción del usuario, ej. clic en un enlace), etc.
- **Propósito:** Ejecución remota de código (RCE), escalada de privilegios (EoP), denegación de servicio (DoS), fuga de información, etc.

Una vez que se descubre una **vulnerabilidad**, el escenario para el desarrollo de un _exploit_ puede variar significativamente:

- **Existencia de Código Exploit Completo:** Un _exploit_ funcional ya ha sido desarrollado y es de dominio público o privado.
- **Existencia de Código Exploit Parcial:** Se dispone de un segmento de código que demuestra la vulnerabilidad, pero requiere modificaciones y adaptaciones para ejecutar un _payload_ específico y lograr un impacto deseado.
- **Ausencia Total de Código Exploit:** En este escenario, el _exploit_ debe ser desarrollado desde cero, lo que representa el mayor desafío y esfuerzo.

El proceso de desarrollar un _exploit_ desde cero es una tarea intensiva que demanda una profunda investigación, paciencia y un conocimiento técnico avanzado. Las fases típicas incluyen:

1. **Recopilación de Información Preliminar:** Identificación de la plataforma, arquitectura y versión específicas donde reside la vulnerabilidad.
2. **Enumeración de Vectores de Ataque:** Análisis exhaustivo de cómo la vulnerabilidad puede ser activada y aprovechada (ej. a través de una petición de red, manipulación de un archivo, entrada de usuario).
3. **Identificación Precisa de la Vulnerabilidad:** Utilización de técnicas como el _fuzzing_ (inyección de entradas malformadas o inesperadas para provocar fallos) para localizar la sección exacta del código vulnerable y los parámetros críticos que desencadenan el comportamiento anómalo.
    - **Ejemplo Práctico de Fuzzing:** Para una aplicación que procesa entradas de usuario, un _fuzzer_ podría enviar cadenas de caracteres extremadamente largas, caracteres especiales, o secuencias no válidas a cada campo de entrada para observar qué entradas causan _crashes_ o comportamientos inesperados, indicando posibles desbordamientos de búfer o _parsing_ incorrecto.
4. **Desarrollo de un Prototipo de Explotación (Proof of Concept - PoC):** Creación de un código mínimo para validar la existencia y explotabilidad de la vulnerabilidad, demostrando un control parcial o un _crash_ reproducible.
5. **Desarrollo del Código Exploit Completo:** Codificación del _exploit_ final, incluyendo la lógica para la inyección del _payload_ y la manipulación de los parámetros exactos (ej. direcciones de retorno en _buffer overflows_).
6. **Publicación y Adaptación a Frameworks:** Una vez estabilizado y validado, el _exploit_ puede ser compartido con la comunidad y, comúnmente, adaptado a _frameworks_ de explotación como Metasploit, lo que facilita su uso y distribución.

La precisión en el desarrollo del _exploit_ es paramétrica y crítica. Por ejemplo, en un _exploit_ de **desbordamiento de búfer**, la **dirección de retorno (Return Address)** es un componente fundamental para la ejecución exitosa del _payload_. Un error mínimo en esta dirección (incluso un solo _byte_) puede llevar al fracaso total del _exploit_.

### 2. Fundamentos del Desbordamiento de Búfer (Buffer Overflow)

El **desbordamiento de búfer** es una de las vulnerabilidades más prevalentes y peligrosas, capaz de permitir la ejecución remota de código arbitrario y la escalada de privilegios en sistemas comprometidos.

#### 2.1. Definición y Mecanismo

Un desbordamiento de búfer ocurre cuando una aplicación intenta escribir más datos en un bloque de memoria (`buffer`) de lo que su capacidad asignada permite, o cuando se intenta escribir datos más allá de los límites predefinidos de dicho búfer.

En este contexto, un **búfer** es una sección de memoria contigua y de tamaño fijo, asignada para almacenar datos temporales, que pueden ser desde una simple cadena de caracteres hasta un arreglo de enteros o estructuras de datos complejas.

La acción de intentar escribir datos fuera de los límites asignados de un búfer puede tener varias consecuencias severas:

- **Corrupción de Datos:** Los datos adyacentes en la memoria son sobrescritos.
- **Caída del Programa (Crash):** El programa termina abruptamente debido a una violación de acceso o un estado inconsistente.
- **Ejecución de Código Malicioso:** En el peor de los casos, la sobrescritura de estructuras de control críticas (como la dirección de retorno en la pila de llamadas) puede redirigir el flujo de ejecución del programa a código arbitrario inyectado por el atacante.

#### 2.2. Ejemplo de Código C

Considérese el siguiente código en lenguaje C, que es vulnerable a un desbordamiento de búfer:

```C
#include <stdio.h>
#include <string.h> // Se añade para usar strcpy de forma insegura en este ejemplo

void AdminFunction()
{
    printf("Welcome!\n");
    printf("You are now in the Admin function!\n");
}

void echo()
{
    char buffer[25]; // Buffer con capacidad para 25 caracteres (más el terminador nulo '\0')
    printf("Enter any text:\n");
    // scanf("%s", buffer); // La función scanf con %s es inherentemente insegura para buffer overflows
    // Se usará fgets para un ejemplo más realista de vulnerabilidad si no se valida el tamaño
    // Pero para ilustrar el overflow directo con entrada del usuario, la original es más clara.
    // Para el propósito de una explicación clara de overflow, la original scanf es más directa.

    // Usaremos gets() o una version insegura de scanf para ilustrar el overflow explícitamente como en el original
    // Advertencia: NUNCA usar scanf %s o gets() en código de producción sin validación estricta de tamaño.
    scanf("%s", buffer); // Inseguro: no verifica el tamaño de la entrada

    printf("You entered: %s\n", buffer);
}

int main()
{
    echo();
    return 0;
}
```

**Análisis de la Vulnerabilidad:**

En la función `echo()`, se declara un arreglo de caracteres `buffer` con un tamaño fijo de **25 bytes**. La función `scanf("%s", buffer);` es el punto de vulnerabilidad. Esta función lee una cadena de caracteres hasta encontrar un espacio en blanco, un tabulador o un salto de línea, **sin realizar ninguna verificación sobre la longitud de la entrada del usuario**.

- **Escenario de Explotación:** Si un usuario ingresa una cadena de más de 25 caracteres (ej. 30, 50, 100 caracteres), `scanf` intentará escribir todos esos caracteres en `buffer`. Como `buffer` solo tiene espacio para 25 caracteres (más un byte para el terminador nulo `\0`), el exceso de caracteres **sobrescribirá la memoria adyacente al búfer** en la pila (stack).
    
- **Consecuencia Práctica:** Esta sobrescritura puede corromper datos vitales, como la **dirección de retorno** de la función `echo()` en la pila. Al finalizar `echo()`, el programa intentará regresar a la dirección especificada en la pila. Si esta dirección ha sido sobrescrita por datos controlados por el atacante, el flujo de ejecución puede ser redirigido a una ubicación arbitraria, permitiendo la ejecución de código malicioso inyectado (el _payload_).
    
- **Ejemplo de Ejecución Maliciosa:** Un atacante podría, al ingresar una cadena excesivamente larga, no solo causar un fallo, sino también inyectar un código shell (shellcode) y sobrescribir la dirección de retorno de la función `echo()` con la dirección de memoria donde reside ese shellcode. Cuando `echo()` termine, el control del programa se transferiría al shellcode del atacante, que podría, por ejemplo, lanzar una _reverse shell_ o ejecutar `AdminFunction()` sin credenciales.

## Fuzzing: Una Técnica Esencial para la Detección de Vulnerabilidades

### 1. El Desafío de la Auditoría de Código Cerrado y la Necesidad de Fuzzers

En el análisis de vulnerabilidades, el acceso al código fuente de una aplicación (`white-box testing`) simplifica enormemente la identificación de fallos de seguridad. Como se ilustró previamente con el ejemplo de desbordamiento de búfer, conocer el tamaño predefinido de un _buffer_ (`char buffer[25];`) permite al analista inferir directamente la cantidad de datos necesaria para provocar un _overflow_ y un _crash_ (`input` > 25 caracteres).

Sin embargo, en la práctica, es común enfrentarse a escenarios de **código cerrado** (`black-box testing` o `grey-box testing`), donde el acceso al código fuente es limitado o inexistente. En estas situaciones, la determinación de la longitud y el formato exacto de una entrada que cause un comportamiento anómalo (como un desbordamiento de búfer o una caída de la aplicación) se convierte en un desafío significativo.

Es precisamente aquí donde los **fuzzers** emergen como una herramienta invaluable.

### 2. Definición y Mecanismo Operacional de los Fuzzers

Los **fuzzers** son herramientas de _software_ automatizadas diseñadas para la detección de vulnerabilidades, particularmente aquellas relacionadas con errores de manejo de entrada. Su principio fundamental se basa en la **inyección de datos semi-aleatorios, malformados o inesperados** (conocidos como "fuzz") en los puntos de entrada de una aplicación objetivo, con el fin de provocar fallos, _crashes_, o comportamientos erróneos que puedan indicar una vulnerabilidad.

El mecanismo operacional básico de un _fuzzer_ implica:

1. **Identificación de Puntos de Entrada (Fuzzing Targets):** Determinar dónde la aplicación acepta entrada de datos (ej. campos de texto, parámetros de URL, cabeceras HTTP, argumentos de línea de comandos, lectura de archivos, _sockets_ de red).
2. **Generación de "Fuzz":** Creación de una amplia variedad de datos de prueba, que pueden incluir:
    - Cadenas extremadamente largas.
    - Valores numéricos fuera de rango (ej. enteros máximos/mínimos).
    - Caracteres especiales o no imprimibles.
    - Secuencias de bytes aleatorias.
    - Datos con formato incorrecto (ej. XML mal formado, JSON incompleto).
3. **Inyección de Datos:** Enviar estos datos generados al punto de entrada identificado de la aplicación.
4. **Monitoreo del Comportamiento:** Observar la aplicación objetivo en busca de indicadores de fallo, tales como:
    - **Caídas (Crashes):** Terminación inesperada de la aplicación.
    - **Errores de Segmentación (Segmentation Faults):** Intentos de acceder a memoria no autorizada.
    - **Excepciones no Manejadas:** Errores de tiempo de ejecución no anticipados.
    - **Congelamiento (Freezes):** La aplicación deja de responder.
    - **Comportamientos Anómalos:** Cualquier desviación del comportamiento esperado.
5. **Reporte y Atribución:** Cuando se detecta un fallo, el _fuzzer_ registra el _input_ específico que lo provocó, permitiendo al analista reproducir la vulnerabilidad y, a menudo, determinar la longitud exacta del _input_ o la secuencia de datos que condujo al _crash_.

### 3. Ejemplos Prácticos de Fuzzing

El _fuzzing_ es una técnica versátil aplicable a diversas capas y tipos de aplicaciones:

- **Fuzzing de Aplicaciones de Escritorio:**
    
    - **Escenario:** Se está auditando un editor de texto propietario del cual no se tiene el código fuente.
    - **Enfoque del Fuzzer:** Un _fuzzer_ podría ser configurado para abrir el editor e inyectar repetidamente contenido aleatorio de longitudes crecientes en el área de texto, o para abrir archivos `.txt` con estructuras malformadas o excesivamente grandes.
    - **Detección:** Si el editor se cierra inesperadamente o muestra un mensaje de error al procesar un archivo de 1 MB lleno de caracteres `A`, el _fuzzer_ reportaría la longitud y el contenido que causó el fallo, indicando una posible vulnerabilidad de desbordamiento de búfer o de manejo de memoria.
- **Fuzzing de Aplicaciones Web:**
    
    - **Escenario:** Una aplicación web con múltiples campos de entrada de usuario y parámetros de URL.
    - **Enfoque del Fuzzer:** Un _fuzzer_ web podría inyectar cadenas de SQL (`' OR 1=1 --`), _scripts_ XSS (`<script>alert(1)</script>`), o cadenas extremadamente largas en campos de usuario, cookies o parámetros GET/POST. También podría enviar datos malformados en los encabezados HTTP.
    - **Detección:** El _fuzzer_ monitorea respuestas HTTP (ej. códigos 500 para errores internos del servidor), tiempos de respuesta inusualmente largos, o mensajes de error que revelen información del _backend_. Si un campo `username` al recibir una cadena de 10.000 caracteres causa un _crash_ del servidor web o una excepción de base de datos, es un indicio claro de vulnerabilidad.
- **Fuzzing de Protocolos de Red:**
    
    - **Escenario:** Un servicio de red (ej. un servidor FTP, un servidor DNS) con un protocolo propietario o estándar.
    - **Enfoque del Fuzzer:** El _fuzzer_ podría generar paquetes de red con campos de encabezado o carga útil (`payload`) malformados, longitudes incorrectas, o secuencias inesperadas, y enviarlos al servicio.
    - **Detección:** Se observa si el servicio se congela, se reinicia, o si se registran errores en el sistema. Por ejemplo, un _fuzzer_ podría enviar una consulta DNS con un nombre de dominio de 500 bytes (cuando el límite RFC es de 255) y ver si el servidor DNS vulnerable se cae.


## Estructura y Modularidad en el Desarrollo de Exploits para Metasploit Framework

### 1\. Plantillas de Módulos de Exploit en Metasploit Framework

El **Metasploit Framework** estandariza el desarrollo de *exploits* mediante el uso de plantillas modulares. Cuando se desarrolla un *exploit* para una vulnerabilidad de día cero (`zero-day vulnerability`) y se desea integrarlo en el *framework*, es imperativo que cumpla con un formato estructurado. Afortunadamente, Metasploit provee esqueletos de módulos que simplifican este proceso, permitiendo al desarrollador enfocarse primariamente en la lógica de explotación.

El esqueleto de un módulo de *exploit* en Metasploit es una clase Ruby que hereda de `Msf::Exploit::Remote`, y contiene campos y métodos predefinidos para encapsular la información y la funcionalidad del *exploit*.

#### 1.1. Estructura General de un Módulo de Exploit

```ruby
##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
require 'msf/core' # Importa la biblioteca central de Metasploit

class MetasploitModule < Msf::Exploit::Remote # Define la clase del módulo, heredando de Msf::Exploit::Remote
  Rank = NormalRanking # Define el ranking de fiabilidad del exploit

  def initialize(info = {}) # Método de inicialización del módulo
    super(update_info(info,
      'Name' => '[Vendor] [Software] [Root Cause] [Vulnerability type]', # Nombre descriptivo del exploit
      'Description' => %q{
        Descripción detallada de la vulnerabilidad y el funcionamiento del módulo.
        Debe ser informativa para el usuario sin necesidad de revisar el código fuente.
      },
      'License' => MSF_LICENSE, # Licencia del módulo (ej. BSD-3-clause)
      'Author' => [ 'Nombre del Autor' ], # Nombre(s) del autor(es)
      'References' =>
        [
          [ 'URL', '' ] # Array de referencias externas (CVE, boletines, blogs)
        ],
      'Platform' => 'win', # Plataforma(s) objetivo (ej. win, linux, osx, bsd, unix)
      'Targets' =>
        [
          [ 'Versión de Sistema/Software Específica', # Array de targets compatibles
            {
              'Ret' => 0x42424242 # Metadatos específicos del target (ej. dirección de retorno)
            }
          ]
        ],
      'Payload' =>
        {
          'BadChars' => '\x00\x00', # Caracteres no permitidos en el payload (evita corrupción)
          # Otras opciones del payload: Space, SaveRegisters, Prepend, Append, etc.
        },
      'Privileged' => true, # Indica si el exploit resulta en privilegios elevados
      'DisclosureDate' => 'MMM DD, AAAA', # Fecha de divulgación pública de la vulnerabilidad
      'DefaultTarget' => 0 # Índice del target por defecto
    ))
  end

  def check # Método opcional para verificar la vulnerabilidad en el objetivo
    # Lógica para sondear el objetivo y determinar la factibilidad del exploit
  end

  def exploit # Método principal donde reside la lógica de explotación
    # Código que ejecuta el ataque
  end
end
```

#### 1.2. Descripción de Campos Clave en la Plantilla

  * **`Name`**: Concatenación del nombre del **proveedor**, el **software**, la **causa raíz** de la vulnerabilidad (componente o función afectada) y el **tipo de vulnerabilidad** (ej. "Microsoft Word RTF Stack Buffer Overflow").
  * **`Description`**: Provee una explicación comprensiva de la funcionalidad del módulo, las consideraciones operacionales y los prerrequisitos. Su propósito es dotar al usuario de un entendimiento claro sin necesidad de analizar el código fuente.
  * **`Author`**: Contiene el nombre del(los) desarrollador(es). Se puede incluir un *handle* de Twitter como comentario (ej. `  'Nombre del Autor #TwitterHandle' `).
  * **`References`**: Un arreglo (`Array`) de identificadores de referencia (`IDs`) y URLs asociadas a la vulnerabilidad o al *exploit* (ej. avisos de seguridad, artículos de blog, CVEs). Para una taxonomía detallada de estos identificadores, consultar la documentación oficial de Metasploit.
  * **`Platform`**: Especifica la(s) plataforma(s) en la(s) que el *exploit* es compatible (ej. `win` para Windows, `linux`, `bsd`, `unix`).
  * **`Targets`**: Un arreglo de configuraciones objetivo, donde cada elemento es a su vez un arreglo con el nombre del sistema/versión y un *hash* de metadatos específicos (ej. `Ret` para la dirección de retorno en un *buffer overflow*, `Offset`, `Gadget`). Cuando el usuario selecciona un *target*, sus metadatos asociados son cargados y accesibles a través del método `target`.
  * **`Payload`**: Define cómo debe ser generado y codificado el *payload*. Contiene opciones como:
      * `BadChars`: Caracteres que no pueden estar presentes en el *shellcode* (ej. `\x00` para terminadores nulos).
      * `Space`: Tamaño máximo del *payload*.
      * `Encoder`: Codificador preferido para el *payload*.
      * `Nop`: Generador de NOPs.
      * Entre otros (`SaveRegisters`, `Prepend`, `Append`, `MaxNops`, `MinNops`, `EncoderType`, `EncoderOptions`, `ExtendedOptions`, `EncoderDontFallThrough`).
  * **`Privileged`**: Un valor booleano (`true`/`false`) que indica si el *exploit* resulta en la obtención de privilegios elevados (`SYSTEM`, `root`).
  * **`DisclosureDate`**: La fecha de divulgación pública de la vulnerabilidad en formato "Mes DD, AAAA" (ej. "Jun 29, 2017").
  * **`check` (Método)**: (Opcional) Implementa la lógica para sondear el objetivo y determinar si es vulnerable al *exploit* antes de ejecutarlo. Esto permite una validación preliminar.
  * **`exploit` (Método)**: Es la función principal (`main`) del módulo, donde se implementa la lógica secuencial del *exploit*, desde la conexión al objetivo hasta la entrega y ejecución del *payload*.

### 2\. Mixins en Metasploit Framework: Modularidad y Reutilización de Código

El concepto de **mixins** en Ruby (el lenguaje de programación de Metasploit) es una característica clave para promover la **modularidad y la reutilización de código**. En términos simplificados, un *mixin* es un módulo (similar a una biblioteca o interfaz en otros lenguajes como C++ o Java) que se incluye en una clase, otorgando a esa clase acceso a todos los métodos y atributos definidos en el *mixin*.

#### 2.1. Funcionalidad de los Mixins

Los *mixins* eliminan la necesidad de "reinventar la rueda" al desarrollar *exploits*. En lugar de escribir código repetitivo para operaciones comunes (ej. establecer una conexión TCP, interactuar con el protocolo SMB), los desarrolladores pueden simplemente incluir el *mixin* relevante y utilizar los métodos ya implementados. Esto no solo ahorra tiempo y esfuerzo, sino que también mejora la consistencia y la fiabilidad del código.

  * **Ejemplo Práctico:** Si un *exploit* necesita establecer una conexión TCP remota y enviar/recibir datos, en lugar de manejar directamente las llamadas al *socket* y la gestión de errores, el desarrollador puede incluir el *mixin* `Exploit::Remote::Tcp`. Esto le permitirá usar métodos predefinidos como `connect()` y `disconnect()` sin preocuparse por los detalles de bajo nivel.

#### 2.2. Acceso a Mixins Disponibles

Los *mixins* de Metasploit Framework se encuentran en el directorio `/lib/msf/core/exploit`.

  * **Comando:** Para listar los *mixins* disponibles, se puede ejecutar `ls /usr/share/metasploit-framework/lib/msf/core/exploit` en un sistema Kali Linux.
    ![[Adjuntos/Pasted image 20250621164545.png]]

#### 2.3. Mixins Comúnmente Utilizados

Algunos de los *mixins* más frecuentes y sus funcionalidades incluyen:

  * **`Exploit::Remote::Tcp`** (ubicado en `lib/msf/core/exploit/tcp.rb`):

      * **Funcionalidad:** Proporciona métodos y opciones para la interacción con *sockets* TCP remotos.
      * **Métodos y Opciones Clave:**
          * Define opciones cruciales como `RHOST` (dirección IP del host remoto), `RPORT` (puerto remoto) y `ConnectTimeout` (tiempo de espera para la conexión).
          * `connect()`: Establece una conexión TCP con el objetivo.
          * `disconnect()`: Cierra la conexión TCP.
          * Crea `self.sock` como el objeto de *socket* global para operaciones posteriores.
          * Soporte para `SSL`, `Proxies`, `CPORT` (puerto de origen local) y `CHOST` (dirección IP de origen local).
          * Funcionalidades de evasión, como el envío de segmentos TCP pequeños para eludir ciertos sistemas de detección.
          * Expone las opciones de usuario como métodos accesibles (ej. `rhost()`, `rport()`, `ssl()`).

  * **`Exploit::Remote::SMB`** (ubicado en `lib/msf/core/exploit/smb.rb`):

      * **Funcionalidad:** Hereda del *mixin* `Exploit::Remote::Tcp` y añade métodos y opciones específicas para la interacción con el protocolo Server Message Block (SMB).
      * **Métodos y Opciones Clave:**
          * `smb_login()`: Permite autenticarse en un recurso SMB.
          * `smb_create()`: Crea archivos o directorios vía SMB.
          * `smb_peer_os()`: Obtiene la información del sistema operativo del *peer* SMB.
          * Define opciones de usuario como `SMBUser`, `SMBPass` y `SMBDomain` para la autenticación SMB.
          * Proporciona métodos de evasión de Sistemas de Prevención de Intrusiones (IPS) específicos para SMB, como `SMB::pipe_evasion`, `SMB::pad_data_level` y `SMB::file_data_level`.

## Integración de Exploits Externos en Metasploit Framework

### 1\. La Necesidad de Incorporar Exploits de Terceros

La dinámica del descubrimiento de vulnerabilidades y el desarrollo de *exploits* es constante. Diariamente se identifican nuevas debilidades en diversas aplicaciones y productos, y con frecuencia, el código de explotación asociado se publica de forma pública. Sin embargo, este código inicial suele presentarse en un formato "crudo" (similar a un *shellcode* independiente) y no es directamente operable dentro de *frameworks* especializados. Adicionalmente, puede transcurrir un período considerable antes de que un *exploit* recién publicado sea oficialmente integrado como un módulo predeterminado en el **Metasploit Framework**.

A pesar de esto, Metasploit ofrece la flexibilidad de **integrar manualmente módulos de *exploit* externos**, permitiendo a los profesionales de la seguridad aprovechar nuevas capacidades de explotación sin esperar las actualizaciones oficiales del *framework*.

Consideremos como caso de estudio la vulnerabilidad **MS17-010**, notoriamente explotada por el *ransomware* WannaCry. Por defecto, en el momento de su divulgación inicial, el *exploit* para MS17-010 no estaba inmediatamente disponible como un módulo integrado en Metasploit.

### 2\. Proceso de Adición de un Exploit Externo

El procedimiento para incorporar un *exploit* externo a Metasploit Framework implica la descarga del módulo y su correcta ubicación dentro de la estructura de directorios del *framework*.

#### 2.1. Obtención del Módulo de Exploit

La **Exploit Database (Exploit-DB)**, accesible en `https://www.exploit-db.com`, es una de las fuentes más fiables y actualizadas para obtener *exploits* y Pruebas de Concepto (*Proof-of-Concepts* - PoCs) para una amplia gama de plataformas, productos y aplicaciones.

  * **Paso Práctico: Descarga del Módulo MS17-010**
    1.  Navegar a la URL `https://www.exploit-db.com/exploits/41891/` en un navegador web.
    2.  Localizar y descargar el código del *exploit*, que generalmente se presenta en formato Ruby (`.rb`). El *exploit* con EDB-ID `41891` corresponde a un "Microsoft Windows - Unauthenticated SMB Remote Code Execution Scanner (MS17-010)", aunque en el contexto original del texto es un *exploit*, y la referencia en la imagen es de un *scanner* (`auxiliary/scanner/smb/smb_ms17_010`). Para propósitos de este ejemplo, asumiremos que se descarga la versión de *exploit* o *scanner* que se desea integrar.
        (Referencia: Figura 10.2 – Searching for exploits in exploit-db)

#### 2.2. Ubicación del Módulo en el Directorio de Metasploit

Una vez descargado el archivo Ruby (`.rb`) del *exploit*, este debe ser colocado en el directorio apropiado dentro de la estructura del Metasploit Framework para que sea reconocido.

  * **Paso Práctico: Copia del Módulo**
    1.  Copiar el archivo `.rb` descargado (ej. `41891.rb`) al directorio de módulos de *exploits* de Metasploit. La ruta predeterminada en Kali Linux es:
        `/usr/share/metasploit-framework/modules/exploits/windows/smb/`
          * **Comando de Copia:**
            ```
            root@kali:~# cp Desktop/41891.rb /usr/share/metasploit-framework/modules/exploits/windows/smb/
            ```
          * **Verificación de Copia:**
            ```bash
            root@kali:~# ls /usr/share/metasploit-framework/modules/exploits/windows/smb/41891.rb
            /usr/share/metasploit-framework/modules/exploits/windows/smb/41891.rb
            ```
        (Referencia: Figura 10.2A – Metasploit Framework directory)
    <!-- end list -->
      * **Nota Importante:** La ruta indicada es la instalación predeterminada en Kali Linux. Si Metasploit está instalado en una ubicación personalizada, la ruta del directorio de módulos deberá ajustarse en consecuencia.

### 2.3. Carga del Nuevo Módulo en Msfconsole

Para que Metasploit Framework reconozca el módulo recién añadido, es necesario recargar su base de datos interna de módulos.

  * **Paso Práctico: Recarga de Módulos**
    1.  Iniciar la consola de Metasploit (`msfconsole`).
    2.  Una vez en la interfaz `msf >`, ejecutar el comando `reload_all`. Este comando fuerza a Metasploit a escanear todos los directorios de módulos y actualizar su índice.
        (Referencia: Figura 10.3 – The reload\_all command in msfconsole)

### 3\. Utilización del Exploit Externo Integrado

Una vez que el módulo ha sido correctamente copiado y la base de datos de Metasploit ha sido recargada, el *exploit* externo puede ser utilizado de la misma manera que cualquier otro módulo preexistente.

  * **Paso Práctico: Configuración y Lanzamiento del Exploit**
    1.  Utilizar el comando `use` seguido de la ruta del módulo (ej. `exploit/windows/smb/41891`).
    2.  Verificar las opciones disponibles con `show options`.
    3.  Configurar los parámetros necesarios, como la dirección IP del host objetivo (`RHOSTS`).
    4.  Lanzar el *exploit* con el comando `exploit` o `run`.
        (Referencia: Figura 10.4 – Listing newly added exploits in msfconsole - Muestra el uso del exploit `auxiliary/windows/smb/41891`, la configuración de `RHOSTS` y la ejecución, lo que sugiere que es un módulo auxiliar de escaneo, no un *exploit* activo en este ejemplo específico de la imagen.)

Mediante este proceso, se logra incorporar con éxito un *exploit* de terceros al Metasploit Framework, ampliando su arsenal de capacidades de explotación contra objetivos vulnerables.

-----